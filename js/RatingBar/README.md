# 方法复用
抽象出父类

**继承**----原型上的方法，实例化父类（可以访问到父类所有方法的对象new father（），赋给son()的原型，--构造函数原型--   
- 当实例化son（）子类的时候，其也会生成一个对象，该对象也能找到已赋值的son（）的原型，而该son（） 原型又是父类生成的对象，这就形成了一个原型链，`js特有的原型链式的继承方式，非类式继承，`
- 形象化就是：
	- 两点间（对象）依靠期间临时的直线（原型）来相互传输（方法和构造函数等）
                        
- **严重问题**：
	- 继承只希望继承其方法而不是其函数，但是以上实例化new father（），后构造函数一定会执行, 如果构造函数太庞大，会影响性能，所以需要重新写方法。
- **问题解决**：
	- 创建一个空的临时函数var F = function(){}; 将父原型赋值给空临时函数原型，再实例化空临时函数再赋给子类原型。
	- 最后再把子类subClass.prototype.construtor = subClass;改成自己函数subClass;
- 形象化就是：两点AB间（对象）依靠期间临时的直线（原型）来相互传输（方法和构造函数，） 需要增加第三个点C（Temp点），这个点作用是只存储需要的方法。将该点通过直线（原型）连接AB，各取所需
	**注**:
	- 例子中用call（），来子类继承父类构造函数。
                
                
问题 ： 每次实例化之后会调用多次，
                
